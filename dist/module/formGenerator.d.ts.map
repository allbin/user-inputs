{"version":3,"sources":["../src/module/formGenerator.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,WAAW,EAAE,MAAM,GAAG,CAAC;AAEhC,OAAO,EAAyC,oBAAoB,EAAE,cAAc,EAA2B,MAAM,GAAG,CAAC;AAEzH,MAAM,WAAW,aAAa;IAC1B,SAAS,EAAE,OAAO,KAAK,CAAC,SAAS,CAAC;IAClC,KAAK,EAAE,MAAM,IAAI,CAAC;IAClB,SAAS,EAAE,MAAM,WAAW,CAAC;IAC7B,cAAc,EAAE,CAAC,cAAc,EAAE,OAAO,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC;CACrE;AAED,MAAM,CAAC,OAAO,UAAU,YAAY,CAAC,aAAa,EAAE,oBAAoB,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,KAAK,IAAI,GAAG,aAAa,CAqMnH;AAED,wBAAgB,2BAA2B,CAAC,aAAa,EAAE,oBAAoB,EAAE,SAAS,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,KAAK,IAAI,GAAG,IAAI,CA2DvH","file":"formGenerator.d.ts","sourcesContent":["import * as React from 'react';\nimport { LooseObject } from '.';\n\nimport { valid_types, input_imports, FormState, FormInputConfigArray, AnyInputConfig, AnyInputConfigWithValue } from '.';\n\nexport interface GeneratedForm {\n    component: typeof React.Component;\n    reset: () => void;\n    getValues: () => LooseObject;\n    setInputConfig: (updated_config: Partial<AnyInputConfig>) => void;\n}\n\nexport default function getInputForm(input_configs: FormInputConfigArray, cb?: (values: any) => void): GeneratedForm {\n    let mounted_form: InputWrapper | null;\n\n    class InputWrapper extends React.Component<any, FormState> {\n        confirmCB: ((values: any) => void) | null;\n\n        constructor(props: any) {\n            super(props);\n\n            let values: { [key: string]: any; } = {};\n            input_configs.forEach((input) => {\n                if (input.type === \"multi_select\") {\n                    let selected_options = input.options.filter(option => input.default_value.includes(option.value));\n                    if (selected_options.length !== input.default_value.length) {\n                        throw new Error(\"UserInput: Default values for multiselect not present in options.\");\n                    }\n                    values[input.key] = selected_options;\n                } else if (input.type === \"select\") {\n                    let selected_option = input.options.find(option => input.default_value === option.value);\n                    if (!selected_option) {\n                        throw new Error(\"UserInput: Default value for select not present in options.\");\n                    }\n                    values[input.key] = selected_option;\n                } else if (input.type === \"numeric\") {\n                    values[input.key] = input.default_value.toString();\n                } else {\n                    values[input.key] = input.default_value;\n                }\n            });\n\n            this.state = {\n                values: values,\n                inputs: input_configs,\n                tag: null,\n            };\n            this.confirmCB = cb || null;\n        }\n\n        componentDidMount() {\n            mounted_form = this;\n        }\n\n        componentWillUnmount() {\n            if (mounted_form === this) {\n                //If another instance of this form has already been mounted\n                //the mounted_form will have changed. Check before resetting it.\n                mounted_form = null;\n            }\n        }\n\n        setConfig(input_config: AnyInputConfigWithValue) {\n            let inputs = this.state.inputs;\n            let input_index = inputs.findIndex(input => input.key === input_config.key);\n            if (input_index < 0) {\n                throw new Error(\"UserInput: Key not found in existing inputs.\");\n            }\n            let values = this.state.values;\n            if (input_config.hasOwnProperty(\"value\")) {\n                if (input_config.type === \"multi_select\") {\n                    let selected_options = input_config.options.filter(option => input_config.value.includes(option.value));\n                    if (selected_options.length !== input_config.value.length) {\n                        throw new Error(\"UserInput: Values for multiselect not present in options.\");\n                    }\n                    values[input_config.key] = selected_options;\n                } else if (input_config.type === \"select\") {\n                    let selected_option = input_config.options.find(option => input_config.value === option.value);\n                    if (!selected_option) {\n                        throw new Error(\"UserInput: Value for select not present in options.\");\n                    }\n                    values[input_config.key] = selected_option;\n                } else if (input_config.type === \"numeric\") {\n                    values[input_config.key] = input_config.value.toString();\n                } else {\n                    values[input_config.key] = input_config.value;\n                }\n            }\n            inputs[input_index] = Object.assign({}, inputs[input_index], input_config);\n            this.setState({\n                inputs: inputs,\n                values: values\n            });\n        }\n\n        getValues() {\n            let values: LooseObject = {};\n            this.state.inputs.forEach((input) => {\n                if (input.type === \"button\" || input.type === \"confirm\") {\n                    return;\n                } else {\n                    return values[input.key] = input_imports[input.type].getParsedValue(input, this.state.values[input.key]);\n                }\n            });\n            return values;\n        }\n\n        resetValues() {\n            let default_values = input_configs.map(input => input.default_value);\n            this.setState({ values: default_values });\n        }\n\n        userConfirmedCB() {\n            if (this.confirmCB) {\n                this.confirmCB(this.getValues());\n            }\n        }\n\n        inputValueChangeCB(key: string, value: any) {\n            let values = Object.assign({}, this.state.values);\n            values[key] = value;\n            this.setState({\n                values: values\n            });\n        }\n\n        isValid() {\n            return this.state.inputs.some((input_config) => {\n                let valid_error = input_imports[input_config.type].validate(input_config, this.state.values[input_config.key]);\n                return valid_error !== null;\n            });\n        }\n\n        renderInputs() {\n            return this.state.inputs.map((input_request, index) => {\n                let InputComponent = input_imports[input_request.type].Input as typeof React.Component;\n                let key = input_request.key || \"input_\" + index;\n                if (input_request.type === \"confirm\") {\n                    return <InputComponent\n                        key={key}\n                        config={input_request}\n                        value={this.state.values[key]}\n                        disabled={this.isValid()}\n                        onClick={() => {\n                            if (input_request.type === \"confirm\") {\n                                this.userConfirmedCB();\n                            }\n                        }}\n                    />;\n                } else if (input_request.type === \"button\") {\n                    return <InputComponent\n                        key={key}\n                        config={input_request}\n                        value={this.state.values[key]}\n                        onClick={() => {\n                            if (input_request.onClick) {\n                                input_request.onClick();\n                            }\n                        }}\n                    />;\n                }\n                return <InputComponent\n                    key={key}\n                    config={input_request}\n                    value={this.state.values[key]}\n                    onChange={(value: any) => {\n                        this.inputValueChangeCB(key, value);\n                    }}\n                />;\n            });\n        }\n\n        render() {\n            return (\n                <div>\n                    { this.renderInputs() }\n                </div>\n            );\n        }\n    }\n\n    return {\n        component: InputWrapper,\n        reset: () => {\n            if (mounted_form) {\n                mounted_form.resetValues();\n            }\n        },\n        getValues: (): LooseObject => {\n            if (!mounted_form) {\n                return {};\n            }\n            return mounted_form.getValues();\n        },\n        setInputConfig: (updated_config: Partial<AnyInputConfigWithValue>) => {\n            if (updated_config.hasOwnProperty(\"key\") === false) {\n                throw new Error(\"UserInput: input_config must contain 'key' property.\");\n            }\n            let inputs = input_configs;\n            let input_index = input_configs.findIndex(input => input.key === updated_config.key);\n            if (input_index < 0) {\n                throw new Error(\"UserInput: Key not found in existing inputs.\");\n            }\n            input_configs[input_index] = Object.assign({}, input_configs[input_index], updated_config);\n            if (mounted_form) {\n                mounted_form.setConfig(inputs[input_index]);\n            }\n        }\n    };\n}\n\nexport function validateFormGeneratorInputs(input_configs: FormInputConfigArray, confirmCB?: (value: any) => void): void {\n    if (input_configs.length < 1) {\n        throw new Error(\"UserInput: GenerateForm requires at least one input.\");\n    }\n    if (!confirmCB) {\n        let inputs_missing_cb = input_configs.filter(input => !input.onValueChange);\n        if (inputs_missing_cb.length > 0) {\n            throw new Error(\"UserInput: GenerateForm without a confirmCB requires every input to specify a onValueChange callback.\");\n        }\n    } else {\n        let confirm_buttons = input_configs.some(input => input.type === \"confirm\");\n        if (!confirm_buttons) {\n            throw new Error(\"UserInput: GenerateForm with a confirmCB is required to have at least one input of type 'confirm'.\");\n        }\n    }\n\n\n    //Check that default_value is set.\n    let invalid_inputs = input_configs.some((input) => {\n        return (input.type !== \"confirm\" && input.type !== \"button\") && input.hasOwnProperty(\"default_value\") === false;\n    });\n    if (invalid_inputs) {\n        throw new Error(\"UserInput: Every input that is not a 'button' or 'confirm' must be configured with a 'default_value'.\");\n    }\n\n\n    //Check that each input has a valid type.\n    invalid_inputs = input_configs.some(input => !valid_types.includes(input.type));\n    if (invalid_inputs) {\n        throw new Error(\"UserInput: Inputs must be configured with a valid 'type'. \" + valid_types.join(','));\n    }\n\n\n    //Check that each input has a key property.\n    invalid_inputs = input_configs.some(input => (input.type !== 'button' && input.type !== 'confirm') && !input.hasOwnProperty('key'));\n    if (invalid_inputs) {\n        throw new Error(\"UserInput: Inputs that are not type 'button' or 'confirm' must be configured with a 'key' property. \");\n    }\n\n\n    //Duplicate key check.\n    let duplicate_keys: Set<string> = new Set();\n    invalid_inputs = input_configs.some((input) => {\n        if (input.type === 'button' || input.type === 'confirm') {\n            return false;\n        }\n        return duplicate_keys.size === duplicate_keys.add(input.key).size;\n    });\n\n\n    //Run each input type's own validation function.\n    let errors: string[] = [];\n    input_configs.forEach((input) => {\n        let valid = input_imports[input.type].validateConfig(input);\n        if (valid) { errors.push(valid); }\n    });\n    if (errors.length > 0) {\n        throw new Error(errors.join('\\n'));\n    }\n}"]}